\documentclass{article}

\usepackage{geometry}
 \geometry{
 a4paper,
 total={170mm,257mm},
 left=20mm,
 top=20mm,
 }
 \usepackage{color}

\newcommand{\talk}[3]{
\vspace{0.5em}~\\
\noindent
\textbf{#1}\\ 
\noindent\emph{#2}\\ 
\noindent#3\\
}

\begin{document}

\noindent
\textbf{\color{red}This document describes the proposed talks for Seminar 17462 but these have not yet been organised into a schedule. Time for talks have been reserved on Monday and Tuesday morning and (as per email to participants) we have allowed 10-15 minutes per talk.}

\talk{Cyrille Artho}{Domain-Specific Languages with Scala, and model-based testing as an example}
{Domain-Specific Languages (DSLs) are often classified into external and internal DSLs. An external DSL is a stand-alone language with its own parser. An internal DSL is an extension of an existing programming language, the host language, offering the user of the DSL domain-specific constructs as well as the constructs of the host language. In this presentation, we will give a brief overview of the concepts and also look at an internal DSL used for model-based testing with the tool ``Modbat".}
\talk{Cindy Eisner}{PSL: The good, the bad and the ugly}{For a specification language to be suitable for formal verification by model checking, it must have sufficient expressive power, its semantics must be formally defined in a rigorous manner, and the complexity of model checking it must be well understood and reasonable. In order to allow widespread adoption in the industry, there is an additional requirement: behavioral specification must be made easy, allowing common properties to be expressed intuitively and succinctly. But while adding syntax is simple, defining semantics without breaking important properties of the existing semantics is surprisingly difficult. In this talk I will discuss various extensions to temporal logic incorporated by PSL, their motivation, and the subtle semantic issues encountered in their definition. I will emphasize where we succeeded, where we were less successful, and point out some features that are still missing.}
\talk{Julien Signoles}{E-ACSL, an Executable Behavioural Interface Specification Language for C Programs}{This talk introduces E-ACSL, a behavioral specification language for C programs. It is based on a typed first order logic whose terms are pure C expressions extended with a few specific keywords. Every construct may be executed at runtime. Among others, it provides assertions, contracts, invariants, data dependencies and ghost code. It is powerful enough to express most functional properties of C programs and encode other properties such as LTL properties and information flow policies.}
\talk{Sylvain Halle}{Stream Transducers + Runtime Parser = A Do-It-Yourself Specification Language}{}
\talk{Torben Scheffel}{TeSSLa}{The Temporal Stream-based Specification Language (TeSSLa) operates on asynchronous real-time streams. It was first created for specifying properties about programs running on multi core systems and it is currently used and developed in the COEMS project. This talk will show the basic motivation for TeSSLa, the basic operators of TeSSLa, application areas and examples.}
\talk{Giles Reger}{What is parametric trace slicing good for?}{Parametric trace slicing is an approach for parametric runtime monitoring that was introduced by tracematches and JavaMOP and later extended by QEA. In this talk I will briefly discuss what it is good for and, perhaps more interesting, what it is not good for.}

\talk{Gordon Pace}{Automata-Based Formalisms for Runtime Verification}{In this talk, I will be looking at a number of visual, graph-based formalisms we have used in various projects and domains, with a particular focus on their use in runtime verification. A discussion of their use in different domains. I will be mentioning DATEs (the formalism used by Larva), ppDATEs (that used by StaRVOOrs), contract automata (used to formalise contracts), policy automata (used for social network privacy policies) and more. A discussion of our exploration above and below this layer will ensue - outlining our experience with controlled natural languages (above) and guarded-commands (below).}
\talk{Wolfgang Ahrendt}{What is more important: Events, or Data, or Both?}{Model checking people, and RV people, often have a focus on events. Deductive versification people, and runtime assertion checking people, have a focus on what happens with, and to, the data. Is the difference really motivated by what either group considers important system properties, or rather by what the respective technologies are good at? To which extent should specification formalisms make a pre-choice? I would mention ppDATE as an EXAMPLE of an attempt to combine aspects on the specification level.}
\talk{Nobuko Yoshida}{The Go Language}{}
\talk{Dmitriy Traytel}{Why my dream language is almost MFODL}{}
\talk{Dejan Nickovic}{Specification Languages for Hardware Monitoring}{}
\talk{Andreas Bauer}{$LTL_{FO}$: why we did it and what problems we solved}{}
\talk{Bernd Finkbeiner}{LOLA}{}
\talk{Borzoo Bonakdarpour and Cesar Sanchez}{Asynchronous HyperLTL}{HyperLTL is a temporal logic for expressing a subclass of hyperproperties. It allows explicit quantification over traces and inter-trace Boolean relations among traces. The current semantics of HyperLTL evaluate formula by progressing a set of traces in a lock-step synchronous manner. In this talk, we will present our recent work on relaxing the semantics of HyperLTL to allow traces to advance with different speeds. While this relaxation makes the verification problem undecidable, the decidable fragment is expressive enough to express most commonly used security policies. Our new semantics has also application in model-based runtime monitoring.}
\talk{Adrian Francalanza}{Specification Languages and the Controllability of Monitors}{}
\talk{Domenico Bianculli}{The Tale of Dr Jekyll and Mr Hyde in Pattern-based Specification Languages}{This talk presents two specification languages, SOLOIST and TemPsy. Both are based on property specification patterns and have been defined in the context of an industrial collaboration. One extends a temporal logic with new modalities; the other defines a domain-specific language  that can express a limited subset of temporal properties.}


\end{document}